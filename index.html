<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Spaceship Shooter</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@300;500;700&display=swap');

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            background: #000;
            overflow: hidden;
            font-family: 'Rajdhani', sans-serif;
            touch-action: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        canvas {
            display: block;
            position: absolute;
            top: 0; left: 0;
        }

        #ui-overlay {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        #hud {
            position: absolute;
            top: 15px; left: 15px; right: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-family: 'Orbitron', monospace;
            color: #0ff;
            font-size: 14px;
            text-shadow: 0 0 10px #0ff, 0 0 20px #0ff;
        }

        #hud .score { font-size: 20px; font-weight: 900; }
        #hud .level { color: #f0f; text-shadow: 0 0 10px #f0f; }
        #hud .lives { color: #f44; text-shadow: 0 0 10px #f44; }

        .health-bar {
            position: absolute;
            bottom: 20px; left: 50%;
            transform: translateX(-50%);
            width: 200px; height: 8px;
            background: rgba(255,255,255,0.1);
            border: 1px solid #0ff;
            border-radius: 4px;
            overflow: hidden;
        }

        .health-bar .fill {
            height: 100%;
            background: linear-gradient(90deg, #0f0, #0ff);
            transition: width 0.3s;
            box-shadow: 0 0 10px #0ff;
        }

        #start-screen, #game-over-screen {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: rgba(0,0,0,0.85);
            pointer-events: all;
            z-index: 20;
        }

        #start-screen h1 {
            font-family: 'Orbitron', monospace;
            font-size: clamp(28px, 6vw, 56px);
            font-weight: 900;
            background: linear-gradient(135deg, #0ff, #f0f, #ff0);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
            text-align: center;
            animation: glow 2s ease-in-out infinite alternate;
        }

        @keyframes glow {
            from { filter: drop-shadow(0 0 10px #0ff); }
            to { filter: drop-shadow(0 0 30px #f0f); }
        }

        #start-screen .subtitle {
            font-family: 'Rajdhani', sans-serif;
            color: #888;
            font-size: clamp(14px, 3vw, 20px);
            margin-bottom: 40px;
            letter-spacing: 4px;
            text-transform: uppercase;
        }

        .btn {
            font-family: 'Orbitron', monospace;
            font-size: clamp(14px, 3vw, 18px);
            padding: 15px 50px;
            border: 2px solid #0ff;
            background: transparent;
            color: #0ff;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 3px;
            transition: all 0.3s;
            margin: 10px;
        }

        .btn:hover {
            background: #0ff;
            color: #000;
            box-shadow: 0 0 30px #0ff, inset 0 0 30px rgba(0,255,255,0.2);
        }

        #start-screen .controls-hint {
            color: #555;
            font-size: 13px;
            margin-top: 30px;
            text-align: center;
            line-height: 1.8;
        }

        #game-over-screen h2 {
            font-family: 'Orbitron', monospace;
            font-size: clamp(24px, 5vw, 44px);
            color: #f44;
            text-shadow: 0 0 20px #f44;
            margin-bottom: 10px;
        }

        #game-over-screen .final-score {
            font-family: 'Orbitron', monospace;
            font-size: clamp(18px, 4vw, 32px);
            color: #0ff;
            margin-bottom: 5px;
        }

        #game-over-screen .final-level {
            font-family: 'Rajdhani', sans-serif;
            font-size: 18px;
            color: #f0f;
            margin-bottom: 30px;
        }

        #mobile-controls {
            display: none;
            position: absolute;
            bottom: 40px;
            left: 0; right: 0;
            justify-content: space-between;
            padding: 0 20px;
            pointer-events: all;
            z-index: 15;
        }

        .mobile-btn {
            width: 60px; height: 60px;
            border-radius: 50%;
            border: 2px solid rgba(0,255,255,0.4);
            background: rgba(0,255,255,0.1);
            color: #0ff;
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            -webkit-tap-highlight-color: transparent;
        }

        .mobile-btn:active {
            background: rgba(0,255,255,0.3);
        }

        .mobile-btn-group {
            display: flex;
            gap: 15px;
        }

        #fire-btn {
            width: 75px; height: 75px;
            border-color: rgba(255,68,68,0.5);
            background: rgba(255,68,68,0.15);
            color: #f44;
            font-size: 14px;
            font-family: 'Orbitron', monospace;
        }

        #fire-btn:active {
            background: rgba(255,68,68,0.4);
        }

        @media (max-width: 768px) {
            #mobile-controls { display: flex; }
            .health-bar { bottom: 120px; }
        }

        @media (pointer: coarse) {
            #mobile-controls { display: flex; }
            .health-bar { bottom: 120px; }
        }
    </style>
</head>
<body>
    <canvas id="game"></canvas>

    <div id="ui-overlay">
        <div id="hud" style="display:none;">
            <div class="score">SCORE: <span id="score">0</span></div>
            <div class="level">WAVE <span id="level">1</span></div>
            <div class="lives">♥ <span id="lives">3</span></div>
        </div>

        <div class="health-bar" id="health-bar" style="display:none;">
            <div class="fill" id="health-fill" style="width:100%"></div>
        </div>

        <div id="mobile-controls">
            <div class="mobile-btn-group">
                <button class="mobile-btn" id="left-btn">◀</button>
                <button class="mobile-btn" id="right-btn">▶</button>
            </div>
            <button class="mobile-btn" id="fire-btn">FIRE</button>
        </div>
    </div>

    <div id="start-screen">
        <h1>SPACESHIP SHOOTER</h1>
        <div class="subtitle">Defend the Galaxy</div>
        <button class="btn" id="start-btn">LAUNCH</button>
        <div class="controls-hint">
            ← → or A/D to move &nbsp;|&nbsp; SPACE to fire<br>
            Touch controls on mobile
        </div>
    </div>

    <div id="game-over-screen" style="display:none;">
        <h2>MISSION FAILED</h2>
        <div class="final-score">SCORE: <span id="final-score">0</span></div>
        <div class="final-level">Wave reached: <span id="final-level">1</span></div>
        <button class="btn" id="restart-btn">TRY AGAIN</button>
    </div>

    <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    // Resize
    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }
    resize();
    window.addEventListener('resize', resize);

    // Game state
    let game = {
        running: false,
        score: 0,
        level: 1,
        lives: 3,
        health: 100,
        maxHealth: 100,
        enemySpawnTimer: 0,
        enemySpawnRate: 90,
        particles: [],
        bullets: [],
        enemyBullets: [],
        enemies: [],
        powerups: [],
        stars: [],
        shakeTimer: 0,
        shakeIntensity: 0,
        enemiesKilled: 0,
        enemiesPerWave: 10,
        waveTransition: false,
        waveTextTimer: 0,
    };

    // Player
    let player = {
        x: 0, y: 0,
        width: 40, height: 50,
        speed: 5,
        fireRate: 12,
        fireTimer: 0,
        invincible: 0,
        weaponLevel: 1,
    };

    // Stars background
    function initStars() {
        game.stars = [];
        for (let i = 0; i < 200; i++) {
            game.stars.push({
                x: Math.random() * canvas.width,
                y: Math.random() * canvas.height,
                size: Math.random() * 2 + 0.5,
                speed: Math.random() * 2 + 0.5,
                brightness: Math.random(),
            });
        }
    }

    // Input
    const keys = {};
    let mobileLeft = false, mobileRight = false, mobileFire = false;

    document.addEventListener('keydown', e => { keys[e.code] = true; e.preventDefault(); });
    document.addEventListener('keyup', e => { keys[e.code] = false; });

    // Mobile controls
    function setupMobile(id, onDown, onUp) {
        const el = document.getElementById(id);
        if (!el) return;
        ['touchstart', 'mousedown'].forEach(evt => {
            el.addEventListener(evt, e => { e.preventDefault(); onDown(); });
        });
        ['touchend', 'mouseup', 'touchcancel'].forEach(evt => {
            el.addEventListener(evt, e => { e.preventDefault(); onUp(); });
        });
    }

    setupMobile('left-btn', () => mobileLeft = true, () => mobileLeft = false);
    setupMobile('right-btn', () => mobileRight = true, () => mobileRight = false);
    setupMobile('fire-btn', () => mobileFire = true, () => mobileFire = false);

    // Touch move on canvas
    let touchX = null;
    canvas.addEventListener('touchstart', e => {
        touchX = e.touches[0].clientX;
    });
    canvas.addEventListener('touchmove', e => {
        if (touchX !== null) {
            const newX = e.touches[0].clientX;
            player.x += (newX - touchX);
            touchX = newX;
        }
        e.preventDefault();
    });
    canvas.addEventListener('touchend', () => { touchX = null; });

    // Particles
    function spawnParticles(x, y, color, count, speed) {
        for (let i = 0; i < count; i++) {
            const angle = Math.random() * Math.PI * 2;
            const vel = Math.random() * speed + 1;
            game.particles.push({
                x, y,
                vx: Math.cos(angle) * vel,
                vy: Math.sin(angle) * vel,
                life: 1,
                decay: Math.random() * 0.03 + 0.015,
                size: Math.random() * 4 + 1,
                color,
            });
        }
    }

    function spawnExplosion(x, y, big) {
        const colors = ['#ff0', '#f80', '#f44', '#fff', '#0ff'];
        const count = big ? 40 : 15;
        const speed = big ? 6 : 3;
        colors.forEach(c => spawnParticles(x, y, c, count / colors.length, speed));
        game.shakeTimer = big ? 15 : 8;
        game.shakeIntensity = big ? 8 : 4;
    }

    // Draw spaceship
    function drawPlayer() {
        const { x, y } = player;
        const flash = player.invincible > 0 && Math.floor(player.invincible / 4) % 2;
        if (flash) return;

        ctx.save();
        ctx.translate(x, y);

        // Engine glow
        const gradient = ctx.createRadialGradient(0, 25, 2, 0, 35, 20);
        gradient.addColorStop(0, 'rgba(0,200,255,0.8)');
        gradient.addColorStop(0.5, 'rgba(0,100,255,0.3)');
        gradient.addColorStop(1, 'transparent');
        ctx.fillStyle = gradient;
        ctx.fillRect(-12, 20, 24, 30);

        // Ship body
        ctx.fillStyle = '#1a1a2e';
        ctx.strokeStyle = '#0ff';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(0, -25);
        ctx.lineTo(-20, 20);
        ctx.lineTo(-15, 25);
        ctx.lineTo(-5, 20);
        ctx.lineTo(5, 20);
        ctx.lineTo(15, 25);
        ctx.lineTo(20, 20);
        ctx.lineTo(0, -25);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();

        // Cockpit
        const cockpit = ctx.createLinearGradient(0, -15, 0, 5);
        cockpit.addColorStop(0, '#0ff');
        cockpit.addColorStop(1, '#06a');
        ctx.fillStyle = cockpit;
        ctx.beginPath();
        ctx.ellipse(0, -5, 6, 12, 0, 0, Math.PI * 2);
        ctx.fill();

        // Wing details
        ctx.strokeStyle = '#f0f';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(-8, 5); ctx.lineTo(-18, 18);
        ctx.moveTo(8, 5); ctx.lineTo(18, 18);
        ctx.stroke();

        ctx.restore();
    }

    // Draw enemy
    function drawEnemy(e) {
        ctx.save();
        ctx.translate(e.x, e.y);

        if (e.type === 'basic') {
            ctx.fillStyle = '#2a0a3a';
            ctx.strokeStyle = '#f0f';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, -15);
            ctx.lineTo(-18, 10);
            ctx.lineTo(-8, 15);
            ctx.lineTo(8, 15);
            ctx.lineTo(18, 10);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            // Eye
            ctx.fillStyle = '#f44';
            ctx.beginPath();
            ctx.arc(0, 0, 4, 0, Math.PI * 2);
            ctx.fill();
        } else if (e.type === 'fast') {
            ctx.fillStyle = '#0a2a1a';
            ctx.strokeStyle = '#0f0';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(0, -12);
            ctx.lineTo(-22, 8);
            ctx.lineTo(0, 3);
            ctx.lineTo(22, 8);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            ctx.fillStyle = '#0f0';
            ctx.beginPath();
            ctx.arc(0, -2, 3, 0, Math.PI * 2);
            ctx.fill();
        } else if (e.type === 'tank') {
            ctx.fillStyle = '#2a1a0a';
            ctx.strokeStyle = '#f80';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(0, 0, 20, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            ctx.strokeStyle = '#ff0';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(0, 0, 12, 0, Math.PI * 2);
            ctx.stroke();
            ctx.fillStyle = '#f44';
            ctx.beginPath();
            ctx.arc(0, 0, 5, 0, Math.PI * 2);
            ctx.fill();
        } else if (e.type === 'boss') {
            ctx.fillStyle = '#1a0020';
            ctx.strokeStyle = '#f0f';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(0, -30);
            ctx.lineTo(-35, 0);
            ctx.lineTo(-25, 25);
            ctx.lineTo(25, 25);
            ctx.lineTo(35, 0);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            // Boss health bar
            const hw = 40;
            ctx.fillStyle = 'rgba(255,0,0,0.3)';
            ctx.fillRect(-hw, -40, hw * 2, 5);
            ctx.fillStyle = '#f44';
            ctx.fillRect(-hw, -40, (e.hp / e.maxHp) * hw * 2, 5);

            // Eyes
            ctx.fillStyle = '#f0f';
            ctx.beginPath();
            ctx.arc(-12, -5, 5, 0, Math.PI * 2);
            ctx.arc(12, -5, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(-12, -5, 2, 0, Math.PI * 2);
            ctx.arc(12, -5, 2, 0, Math.PI * 2);
            ctx.fill();
        }

        ctx.restore();
    }

    // Spawn enemy
    function spawnEnemy() {
        const types = ['basic', 'basic', 'basic', 'fast', 'fast', 'tank'];
        const type = types[Math.floor(Math.random() * Math.min(types.length, 3 + game.level))];
        const e = {
            x: Math.random() * (canvas.width - 60) + 30,
            y: -30,
            type,
            fireTimer: Math.random() * 120,
            time: 0,
        };

        if (type === 'basic') {
            e.speed = 1.5 + game.level * 0.2;
            e.hp = 1; e.maxHp = 1;
            e.score = 100;
            e.width = 36; e.height = 30;
            e.fireRate = 120;
        } else if (type === 'fast') {
            e.speed = 3 + game.level * 0.3;
            e.hp = 1; e.maxHp = 1;
            e.score = 150;
            e.width = 44; e.height = 20;
            e.fireRate = 200;
            e.amplitude = 80;
            e.startX = e.x;
        } else if (type === 'tank') {
            e.speed = 0.8 + game.level * 0.1;
            e.hp = 3 + Math.floor(game.level / 2);
            e.maxHp = e.hp;
            e.score = 300;
            e.width = 40; e.height = 40;
            e.fireRate = 80;
        }

        game.enemies.push(e);
    }

    function spawnBoss() {
        game.enemies.push({
            x: canvas.width / 2,
            y: -60,
            type: 'boss',
            speed: 0.5,
            hp: 20 + game.level * 10,
            maxHp: 20 + game.level * 10,
            score: 2000,
            width: 70, height: 55,
            fireRate: 40,
            fireTimer: 0,
            time: 0,
            phase: 0,
        });
    }

    // Powerups
    function spawnPowerup(x, y) {
        if (Math.random() > 0.15) return;
        const types = ['health', 'weapon', 'life'];
        const weights = [0.5, 0.35, 0.15];
        let r = Math.random(), type;
        if (r < weights[0]) type = 'health';
        else if (r < weights[0] + weights[1]) type = 'weapon';
        else type = 'life';

        game.powerups.push({ x, y, type, speed: 2, size: 12, time: 0 });
    }

    // Update
    function update() {
        if (!game.running) return;

        const W = canvas.width, H = canvas.height;

        // Player movement
        let dx = 0;
        if (keys['ArrowLeft'] || keys['KeyA'] || mobileLeft) dx = -player.speed;
        if (keys['ArrowRight'] || keys['KeyD'] || mobileRight) dx = player.speed;
        player.x = Math.max(25, Math.min(W - 25, player.x + dx));

        // Firing
        player.fireTimer--;
        if ((keys['Space'] || mobileFire) && player.fireTimer <= 0) {
            player.fireTimer = player.fireRate;
            const bx = player.x, by = player.y - 30;
            if (player.weaponLevel >= 3) {
                game.bullets.push({ x: bx, y: by, speed: 10, damage: 1 });
                game.bullets.push({ x: bx - 15, y: by + 5, speed: 9, damage: 1, angle: -0.1 });
                game.bullets.push({ x: bx + 15, y: by + 5, speed: 9, damage: 1, angle: 0.1 });
            } else if (player.weaponLevel >= 2) {
                game.bullets.push({ x: bx - 8, y: by, speed: 10, damage: 1 });
                game.bullets.push({ x: bx + 8, y: by, speed: 10, damage: 1 });
            } else {
                game.bullets.push({ x: bx, y: by, speed: 10, damage: 1 });
            }
        }

        if (player.invincible > 0) player.invincible--;

        // Bullets
        game.bullets = game.bullets.filter(b => {
            b.y -= b.speed;
            if (b.angle) b.x += Math.sin(b.angle) * 3;
            return b.y > -10;
        });

        // Enemy bullets
        game.enemyBullets = game.enemyBullets.filter(b => {
            b.x += b.vx || 0;
            b.y += b.vy || 2;
            return b.y < H + 10 && b.x > -10 && b.x < W + 10;
        });

        // Enemies
        if (!game.waveTransition) {
            game.enemySpawnTimer--;
            if (game.enemySpawnTimer <= 0 && game.enemiesKilled < game.enemiesPerWave) {
                spawnEnemy();
                game.enemySpawnTimer = Math.max(20, game.enemySpawnRate - game.level * 5);
            }
        }

        game.enemies = game.enemies.filter(e => {
            e.time++;
            e.y += e.speed;

            if (e.type === 'fast' && e.startX !== undefined) {
                e.x = e.startX + Math.sin(e.time * 0.05) * e.amplitude;
            }
            if (e.type === 'boss') {
                e.y = Math.min(80, e.y);
                e.x = W / 2 + Math.sin(e.time * 0.02) * (W * 0.3);
            }

            // Enemy firing
            e.fireTimer--;
            if (e.fireTimer <= 0 && e.y > 0) {
                e.fireTimer = e.fireRate;
                const angle = Math.atan2(player.y - e.y, player.x - e.x);
                const speed = e.type === 'boss' ? 4 : 3;
                game.enemyBullets.push({
                    x: e.x, y: e.y + 10,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    color: e.type === 'boss' ? '#f0f' : '#f44',
                });
                if (e.type === 'boss' && e.time % 3 === 0) {
                    game.enemyBullets.push({ x: e.x - 20, y: e.y + 15, vx: -1, vy: 3, color: '#f0f' });
                    game.enemyBullets.push({ x: e.x + 20, y: e.y + 15, vx: 1, vy: 3, color: '#f0f' });
                }
            }

            // Off screen
            if (e.y > H + 40) return false;

            // Collision with player bullets
            for (let i = game.bullets.length - 1; i >= 0; i--) {
                const b = game.bullets[i];
                if (Math.abs(b.x - e.x) < e.width / 2 && Math.abs(b.y - e.y) < e.height / 2) {
                    game.bullets.splice(i, 1);
                    e.hp -= b.damage;
                    spawnParticles(b.x, b.y, '#0ff', 5, 2);
                    if (e.hp <= 0) {
                        game.score += e.score;
                        game.enemiesKilled++;
                        spawnExplosion(e.x, e.y, e.type === 'boss' || e.type === 'tank');
                        spawnPowerup(e.x, e.y);
                        updateHUD();

                        // Wave progression
                        if (game.enemiesKilled >= game.enemiesPerWave && !game.waveTransition) {
                            if (game.level % 3 === 0) {
                                spawnBoss();
                            }
                            game.waveTransition = true;
                            game.waveTextTimer = 120;
                        }
                        if (game.waveTransition && game.enemies.length <= 1) {
                            game.level++;
                            game.enemiesKilled = 0;
                            game.enemiesPerWave = 10 + game.level * 3;
                            game.waveTransition = false;
                            game.waveTextTimer = 120;
                            updateHUD();
                        }

                        return false;
                    }
                }
            }

            // Collision with player
            if (player.invincible <= 0) {
                if (Math.abs(player.x - e.x) < (e.width / 2 + 15) &&
                    Math.abs(player.y - e.y) < (e.height / 2 + 20)) {
                    takeDamage(20);
                    spawnExplosion(e.x, e.y, false);
                    return false;
                }
            }

            return true;
        });

        // Enemy bullets hit player
        if (player.invincible <= 0) {
            game.enemyBullets = game.enemyBullets.filter(b => {
                if (Math.abs(b.x - player.x) < 15 && Math.abs(b.y - player.y) < 20) {
                    takeDamage(10);
                    spawnParticles(b.x, b.y, '#f44', 8, 3);
                    return false;
                }
                return true;
            });
        }

        // Powerups
        game.powerups = game.powerups.filter(p => {
            p.y += p.speed;
            p.time++;
            if (p.y > H + 20) return false;

            if (Math.abs(p.x - player.x) < 25 && Math.abs(p.y - player.y) < 25) {
                if (p.type === 'health') {
                    game.health = Math.min(game.maxHealth, game.health + 30);
                    spawnParticles(p.x, p.y, '#0f0', 10, 3);
                } else if (p.type === 'weapon') {
                    player.weaponLevel = Math.min(3, player.weaponLevel + 1);
                    spawnParticles(p.x, p.y, '#ff0', 10, 3);
                } else if (p.type === 'life') {
                    game.lives++;
                    spawnParticles(p.x, p.y, '#f44', 10, 3);
                }
                updateHUD();
                return false;
            }
            return true;
        });

        // Particles
        game.particles = game.particles.filter(p => {
            p.x += p.vx;
            p.y += p.vy;
            p.life -= p.decay;
            p.vx *= 0.98;
            p.vy *= 0.98;
            return p.life > 0;
        });

        // Stars
        game.stars.forEach(s => {
            s.y += s.speed;
            if (s.y > H) { s.y = 0; s.x = Math.random() * W; }
        });

        // Wave text timer
        if (game.waveTextTimer > 0) game.waveTextTimer--;

        // Screen shake
        if (game.shakeTimer > 0) game.shakeTimer--;
    }

    function takeDamage(amount) {
        game.health -= amount;
        player.invincible = 60;
        game.shakeTimer = 10;
        game.shakeIntensity = 6;
        spawnParticles(player.x, player.y, '#f44', 15, 4);

        if (game.health <= 0) {
            game.lives--;
            if (game.lives <= 0) {
                gameOver();
                return;
            }
            game.health = game.maxHealth;
            player.weaponLevel = Math.max(1, player.weaponLevel - 1);
        }
        updateHUD();
    }

    // Draw
    function draw() {
        const W = canvas.width, H = canvas.height;
        ctx.clearRect(0, 0, W, H);

        // Background
        ctx.fillStyle = '#000010';
        ctx.fillRect(0, 0, W, H);

        // Screen shake
        if (game.shakeTimer > 0) {
            const s = game.shakeIntensity * (game.shakeTimer / 15);
            ctx.save();
            ctx.translate(Math.random() * s - s / 2, Math.random() * s - s / 2);
        }

        // Stars
        game.stars.forEach(s => {
            const alpha = 0.3 + s.brightness * 0.7;
            ctx.fillStyle = `rgba(200,220,255,${alpha})`;
            ctx.fillRect(s.x, s.y, s.size, s.size);
        });

        // Nebula effect
        const nebula = ctx.createRadialGradient(W * 0.3, H * 0.4, 0, W * 0.3, H * 0.4, W * 0.5);
        nebula.addColorStop(0, 'rgba(100,0,150,0.03)');
        nebula.addColorStop(1, 'transparent');
        ctx.fillStyle = nebula;
        ctx.fillRect(0, 0, W, H);

        if (game.running) {
            // Powerups
            game.powerups.forEach(p => {
                const pulse = Math.sin(p.time * 0.1) * 3;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size + pulse, 0, Math.PI * 2);
                if (p.type === 'health') {
                    ctx.fillStyle = 'rgba(0,255,0,0.3)';
                    ctx.strokeStyle = '#0f0';
                } else if (p.type === 'weapon') {
                    ctx.fillStyle = 'rgba(255,255,0,0.3)';
                    ctx.strokeStyle = '#ff0';
                } else {
                    ctx.fillStyle = 'rgba(255,68,68,0.3)';
                    ctx.strokeStyle = '#f44';
                }
                ctx.fill();
                ctx.lineWidth = 2;
                ctx.stroke();

                ctx.fillStyle = '#fff';
                ctx.font = '12px Orbitron';
                ctx.textAlign = 'center';
                ctx.fillText(p.type === 'health' ? '+' : p.type === 'weapon' ? 'W' : '♥', p.x, p.y + 4);
            });

            // Player bullets
            game.bullets.forEach(b => {
                const grad = ctx.createLinearGradient(b.x, b.y, b.x, b.y + 12);
                grad.addColorStop(0, '#0ff');
                grad.addColorStop(1, 'transparent');
                ctx.fillStyle = grad;
                ctx.fillRect(b.x - 2, b.y, 4, 12);
                ctx.fillStyle = '#fff';
                ctx.fillRect(b.x - 1, b.y, 2, 6);
            });

            // Enemy bullets
            game.enemyBullets.forEach(b => {
                ctx.fillStyle = b.color || '#f44';
                ctx.beginPath();
                ctx.arc(b.x, b.y, 4, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(b.x, b.y, 1.5, 0, Math.PI * 2);
                ctx.fill();
            });

            // Enemies
            game.enemies.forEach(drawEnemy);

            // Player
            drawPlayer();

            // Particles
            game.particles.forEach(p => {
                ctx.globalAlpha = p.life;
                ctx.fillStyle = p.color;
                ctx.fillRect(p.x - p.size / 2, p.y - p.size / 2, p.size, p.size);
            });
            ctx.globalAlpha = 1;

            // Wave text
            if (game.waveTextTimer > 0) {
                const alpha = Math.min(1, game.waveTextTimer / 30);
                ctx.globalAlpha = alpha;
                ctx.fillStyle = '#0ff';
                ctx.font = '900 36px Orbitron';
                ctx.textAlign = 'center';
                ctx.shadowColor = '#0ff';
                ctx.shadowBlur = 20;
                ctx.fillText(`WAVE ${game.level}`, W / 2, H / 2);
                ctx.shadowBlur = 0;
                ctx.globalAlpha = 1;
            }
        }

        if (game.shakeTimer > 0) ctx.restore();
    }

    // Game loop
    function loop() {
        update();
        draw();
        requestAnimationFrame(loop);
    }

    function updateHUD() {
        document.getElementById('score').textContent = game.score;
        document.getElementById('level').textContent = game.level;
        document.getElementById('lives').textContent = game.lives;
        document.getElementById('health-fill').style.width = (game.health / game.maxHealth * 100) + '%';
    }

    function startGame() {
        game = {
            ...game,
            running: true, score: 0, level: 1, lives: 3,
            health: 100, maxHealth: 100,
            enemySpawnTimer: 60, enemySpawnRate: 90,
            particles: [], bullets: [], enemyBullets: [],
            enemies: [], powerups: [],
            enemiesKilled: 0, enemiesPerWave: 10,
            waveTransition: false, waveTextTimer: 120,
            shakeTimer: 0,
        };
        player.x = canvas.width / 2;
        player.y = canvas.height - 80;
        player.weaponLevel = 1;
        player.invincible = 60;

        document.getElementById('start-screen').style.display = 'none';
        document.getElementById('game-over-screen').style.display = 'none';
        document.getElementById('hud').style.display = 'flex';
        document.getElementById('health-bar').style.display = 'block';
        updateHUD();
    }

    function gameOver() {
        game.running = false;
        document.getElementById('final-score').textContent = game.score;
        document.getElementById('final-level').textContent = game.level;
        document.getElementById('game-over-screen').style.display = 'flex';
        document.getElementById('hud').style.display = 'none';
        document.getElementById('health-bar').style.display = 'none';
    }

    document.getElementById('start-btn').addEventListener('click', startGame);
    document.getElementById('restart-btn').addEventListener('click', startGame);

    initStars();
    loop();
    </script>
</body>
</html>
